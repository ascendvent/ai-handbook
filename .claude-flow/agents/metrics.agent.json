{
  "name": "Metrics and Telemetry Agent",
  "version": "1.0.0",
  "description": "Records effectiveness metrics for runs and produces weekly performance reports",
  "triggers": [
    "run_finish",
    "pull_request.opened",
    "pull_request.closed",
    "schedule:weekly"
  ],
  "environment": {
    "METRICS_DB_URL": "${secrets.METRICS_DB_URL}",
    "SLACK_WEBHOOK_URL": "${secrets.SLACK_WEBHOOK_URL}"
  },
  "actions": [
    {
      "name": "record_run_metrics",
      "description": "Log Service Level Indicators to PostgreSQL",
      "type": "database_insert",
      "table": "agent_runs",
      "required_fields": [
        "run_id",
        "agent_name",
        "flow_type",
        "repo",
        "branch",
        "start_ts",
        "end_ts",
        "status",
        "input_tokens",
        "output_tokens",
        "api_cost_usd"
      ],
      "optional_fields": [
        "spec_id",
        "human_intervened",
        "notes"
      ]
    },
    {
      "name": "record_assertions",
      "description": "Log individual test assertions and checks",
      "type": "database_insert",
      "table": "agent_assertions",
      "fields": [
        "run_id",
        "check_name",
        "passed",
        "details"
      ]
    },
    {
      "name": "calculate_sli_metrics",
      "description": "Compute Service Level Indicators",
      "type": "metrics_calculation",
      "metrics": [
        {
          "name": "task_success_rate",
          "formula": "COUNT(CASE WHEN status = 'success' THEN 1 END) / COUNT(*) * 100",
          "unit": "percent"
        },
        {
          "name": "mean_time_to_completion",
          "formula": "AVG(EXTRACT(EPOCH FROM (end_ts - start_ts)))",
          "unit": "seconds"
        },
        {
          "name": "human_intervention_rate",
          "formula": "COUNT(CASE WHEN human_intervened = true THEN 1 END) / COUNT(*) * 100",
          "unit": "percent"
        },
        {
          "name": "cost_per_successful_task",
          "formula": "SUM(api_cost_usd) / COUNT(CASE WHEN status = 'success' THEN 1 END)",
          "unit": "usd"
        },
        {
          "name": "defect_rate",
          "formula": "COUNT(CASE WHEN status = 'fail' THEN 1 END) / COUNT(*) * 100",
          "unit": "percent"
        }
      ]
    },
    {
      "name": "generate_weekly_report",
      "description": "Create weekly markdown report with metrics and trends",
      "type": "report_generation",
      "schedule": "0 9 * * MON",
      "output_file": "/docs/reports/agent-metrics-${date}.md",
      "template": {
        "title": "# Agent Effectiveness Report - Week of ${start_date}",
        "sections": [
          {
            "name": "Executive Summary",
            "content": [
              "- **Task Success Rate:** ${task_success_rate}%",
              "- **Mean Completion Time:** ${mean_time_to_completion}s",
              "- **Human Intervention Rate:** ${human_intervention_rate}%",
              "- **Cost per Successful Task:** $${cost_per_successful_task}",
              "- **Defect Rate:** ${defect_rate}%"
            ]
          },
          {
            "name": "Week-over-Week Comparison",
            "content": "Performance trends and regression alerts"
          },
          {
            "name": "Top Performing Agents",
            "content": "Agents ranked by success rate and efficiency"
          },
          {
            "name": "Recommendations",
            "content": "Suggested improvements based on metrics analysis"
          }
        ]
      }
    },
    {
      "name": "detect_regressions",
      "description": "Surface performance regressions using simple rulesets",
      "type": "regression_analysis",
      "rules": [
        {
          "name": "success_rate_drop",
          "condition": "current_week_success_rate < previous_week_success_rate - 10",
          "severity": "high",
          "action": "send_slack_alert",
          "message": ":warning: Success rate dropped by ${drop_percentage}% week-over-week"
        },
        {
          "name": "cost_increase",
          "condition": "current_week_cost_per_task > previous_week_cost_per_task * 1.5",
          "severity": "medium",
          "action": "send_slack_alert",
          "message": ":chart_with_upwards_trend: Cost per task increased by ${increase_percentage}%"
        },
        {
          "name": "intervention_spike",
          "condition": "current_week_intervention_rate > previous_week_intervention_rate + 15",
          "severity": "medium",
          "action": "send_slack_alert",
          "message": ":hand: Human intervention rate spiked to ${current_intervention_rate}%"
        }
      ]
    }
  ],
  "database_schema": {
    "agent_runs": {
      "id": "bigserial primary key",
      "run_id": "text unique not null",
      "agent_name": "text not null",
      "flow_type": "text not null",
      "repo": "text not null",
      "branch": "text not null",
      "spec_id": "text",
      "start_ts": "timestamptz not null",
      "end_ts": "timestamptz not null",
      "status": "text not null",
      "human_intervened": "boolean default false",
      "input_tokens": "bigint default 0",
      "output_tokens": "bigint default 0",
      "api_cost_usd": "numeric(12,6) default 0",
      "notes": "jsonb default '{}'::jsonb"
    },
    "agent_assertions": {
      "id": "bigserial primary key",
      "run_id": "text not null references agent_runs(run_id) on delete cascade",
      "check_name": "text not null",
      "passed": "boolean not null",
      "details": "jsonb default '{}'::jsonb"
    },
    "spend_totals": {
      "env": "text primary key",
      "total_usd": "numeric(12,6) not null default 0",
      "next_threshold_usd": "numeric(12,2) not null default 5"
    }
  },
  "reports": {
    "output_directory": "/docs/reports/",
    "format": "markdown",
    "retention_days": 90
  },
  "notifications": {
    "slack": {
      "webhook_url": "${env.SLACK_WEBHOOK_URL}",
      "channel": "#ai-metrics",
      "username": "Metrics Agent"
    }
  },
  "success_criteria": {
    "metrics_recorded": true,
    "report_generated": true,
    "regressions_detected": true
  },
  "failure_conditions": [
    {
      "condition": "database_connection_failed",
      "message": "Cannot record metrics - database unavailable"
    },
    {
      "condition": "insufficient_data",
      "message": "Cannot generate report - insufficient data points"
    }
  ]
}